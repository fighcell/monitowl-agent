# -*- encoding: utf-8 -*-
'''
Base definitions for types flowing in the system.


.. _primitives:

Primitives
==========

*Primitives* are basic types to represent most of data in system and all data
gathered from :ref:`sensors`.

Specification
-------------

Primitives are types used to present data which are processed in the system.
They are used on :ref:`monitoring_zone` to hold gathered data and they are used
in conjunction with :ref:`timeseries` to present :ref:`data streams <stream>`
during data processing on the server side.

Base type for each primitive exists in `whmonit.common.primitives.PrimitiveBase`.
This base class enforces that primitive must have implemented:

* unique textual representation of a type name (using for serialization)

* (optional) various operators

* serialization/deserialization mechanizm

Simple primitives
~~~~~~~~~~~~~~~~~

Primitives can be a simple python types like str [as bytestream], unicode,
int, float, dict, list – wrapped in base class.

Complex primitives
~~~~~~~~~~~~~~~~~~

Primitives can also be complex structures. Such types are needed sometimes to
better organize/represent data generated by :ref:`sensors <sensor>` (for
example to enforce structure inside dictionary type for easier accessing the
data or to handle binary form of the data with nice interface).

Complex primitive (yes, it sounds odd) is a type built from simple types (it is
composite type) and has structure – this requirement is dictated by the need to
serialize data which has no own serializers registered in a system (as they are
built from simple types they can be serialized because mentioned base types are
serialized by default by many standard serializers).

Versioning
~~~~~~~~~~


.. warning::

    Version of a primitive is the same as a WHMonit system version
    defined in `whmonit.__init__:__version__`.

    It keeps fragmentation of versions of different primitives in a reasonable
    level and stop the number of different versions of objects in system to
    grow/explode. Imagine 200 primitives in the system each in two or three
    versions.  This schema enforces that one version of a system must be
    consistent (all parts have the same version and have to work together around
    this version).

    Example (for applied schema):

        You have system in version 3 and you know that all primitives are in
        version 3 and all parts (collector, sensors, agent) use the same
        version so you can be sure they can handle all this types and can work
        together.

    Example 2 (for separate versioning):

        You have system in version 3 and some primitives in versions 3, 2, 1,
        so you are not sure* in which version of a system they were upgraded
        and you are not sure they are compatible with sensors with different
        versions. You are not sure they work together.

        * of course you can be sure if you check it, but it will be a pain to
          check a lot of different numbers in different subsystems.

Complex type structures can evolve during the time. For example new fields can
be added or removed. To handle these changes in correct way during the system
life – several mechanisms can be used.

.. note::

    Removing *things* is not a really good idea to do in this case (better ways
    described below). The rest of processing mechanism can rely on data
    availability (can expect some data structure).  So you probably have to
    change the way that mechanisms handle that data, recalculate previous
    results and then remove part of a structure).

Firstly, when you design :ref:`sensor's <sensor>` and :ref:`abacuses' <abacus>`
data structures (primitives) you can split data into smaller parts called
:ref:`streams <stream>`. Each stream is defined as a name and a primitive type.
You can add streams (and sometimes remove them) easily and do not touch the
versioning mechanizm at all – the good way. Side effect is that when you are
using a stream to do calculations and you remove it, it can trigger some
notifications – so you have to remove calculations using this stream first.

Secondly, when you decide that :ref:`primitive's <primitives>` structure has to
be changed (for example because time format of some command has changed and you
want to redesign this structure despite the fact a better way is to handle date
format modification in sensor) you can write new version of it. There are some
rules how to do it to handle old versions of data structure correctly.

* Once more, try to avoid it — change sensor code to adjust to new situation.

* Once more, think about adding a :ref:`stream` instead of reimplement
  primitive.

* But... if you decide to do so – while implementing of a new structure you
  have to set fixed version number.  This version tells when this
  implementation should be used.

* You also have to implement the migrating mechanizm also (only from previous
  version, the previous versions can be `chained` in that way).

* You MUST NEVER delete old version implementations (or you will not be able
  to operate on it).

To illustrate above rules there is an example:

    You have 3 versions of primitive: 1, 2 and 3. When sensor is
    producing streams with primitives in version 2, and you has version of
    a system on the server side in version 3, the implementation 2 will be used to
    `catch` the data and then implementation 3 will be used to process it in
    the system.



'''
import re
# TODO #704: short time ranges in datetime object
from datetime import datetime
from collections import namedtuple
from enum import Enum

from whmonit.common.enums import ID_BYTES_LENGTH
from whmonit.common.error import Error, ArgumentTypeError
from whmonit.common.error import ArgumentValueError


class RegistryBaseError(Error):
    '''Error base class for primitives registry.'''


class AlreadyRegisteredError(RegistryBaseError):
    '''Primitive already registered.'''
    text = 'Primitive {primitive} is already registered in the system.'
    params = 'primitive'


# too many ancestors, where?
# pylint: disable=R0901
class NotRegisteredError(RegistryBaseError, KeyError):
    '''You want to use a primitive that is not registered.'''
    text = 'Primitive "{primitive}" is not registered yet.'
    params = 'primitive'


class NameNotRegisteredError(NotRegisteredError):
    '''You want to use type with a name which is not registered in TypeRegistry.'''
    text = '''Type with name "{name}" is not registered in TypeRegistry.'''
    params = 'name'


class NotASpecificTypeError(RegistryBaseError):
    ''' Type is not a specific realization of a given template. '''
    params = 'type, template'
    text = 'Type given: {type}. Template given: {template}.'


class GenericContainer(object):
    '''
    Generic container object.
    All other containers in the system should subclass it.
    '''
    # Too few public methods.
    # pylint: disable=R0903

    #: Type used as value type in this class. Read-only, set
    #: internally for subclasses.
    item_type = None


class PrimitiveTypeRegistry(object):
    '''
    Registry-like container for keeping `primitive` types.

    .. automethod:: __init__
    '''

    def __init__(self):
        '''
        Initialize primitives registry.
        '''
        self._registry = set()

    def __contains__(self, type_):
        '''`in` operator. Checks that `type` is already registered in registry
        (as primitive or is TimeSeries of registered primitive or is X).'''

        return self.is_valid_type(type_)

    @property
    def primitives(self):
        '''Iterate over registered primitives (uses generator).'''
        return iter(self._registry)

    def register_many(self, list_of_primitive_types):
        '''Like :meth:`register` but you can pass iterable of primitives.'''
        for primitive_type in list_of_primitive_types:
            self.register(primitive_type)

    def register(self, primitive_type):
        '''Register `primitive_type` within type registry.

        :param primitive_type: python type
        :raises: :class:`AlreadyRegisteredError` — if a primitive is already
            registered, :class:`ArgumentTypeError` – if passed `primitive_type`
            is not python type.
        '''
        if not isinstance(primitive_type, type):
            raise ArgumentTypeError('primitive_type',
                                    type(primitive_type),
                                    'It must be a python type')

        if primitive_type in self:
            raise AlreadyRegisteredError(primitive_type)

        self._registry.add(primitive_type)

    def unregister(self, primitive_type):
        '''
        Unregister, previously registered primitive.

        :raises: NotRegisteredError
        '''
        if primitive_type in self:
            self._registry.remove(primitive_type)
        else:
            raise NotRegisteredError(primitive_type)

    def is_valid_type(self, primitive_type):
        '''
        Checks if `primitive_type` is a valid type accepted by system.
        '''
        if primitive_type in self._registry:
            return True

        return (
            isinstance(primitive_type, type) and
            issubclass(primitive_type, GenericContainer) and
            primitive_type.item_type in self
        )


class SensorConfig(dict):
    '''
    This type holds sensor's configuration. Essentially configuration is stored
    in ``dict`` type object but we don't want to have ``dict`` in TYPE_REGISTRY
    but only this specific one. Also this helps distinguish sensor config in
    serialization.
    '''

    defaults = {
        'memory_limit': 60000000,  # ~56MB
        'run_timeout': 5,          # 5 secs
    }

    def __init__(self, *args, **kwargs):
        # Set default values first then eventually override them.
        self.update(SensorConfig.defaults)
        super(SensorConfig, self).__init__(*args, **kwargs)


#: Type representing ``config entry``. Pylint thinks this is a constant and argues
#: it should be uppercase [C0103].
LogDBConfigEntry = namedtuple("LogDBConfigEntry", ["config_id", "target_id",
                              "agent_id", "sensor_name", "timestamp", "config"])


class ID(unicode):
    '''
    Type holds various ids: ``config_id``, ``target_id`` etc. Its purpose
    is similar to ``SensorConfig`` type.
    '''
    # R0904: Too many public methods.
    # pylint: disable=R0904

    regex = re.compile(r'[a-fA-F0-9]{{{}}}$'.format(ID_BYTES_LENGTH))

    def __init__(self, val):
        if not isinstance(val, basestring):
            raise ArgumentTypeError("val", type(val), "basestring")
        if not self.regex.match(val):
            raise ArgumentValueError(
                "val", val,
                "must match regexp: {} (python SHA1 str)".format(self.regex.pattern))
        super(ID, self).__init__(val)


class SensorName(unicode):
    '''
    Type holds sensor name etc. Its purpose is similar to ``SensorConfig``
    type.
    '''
    # R0904: Too many public methods.
    # pylint: disable=R0904

    regex = re.compile(r"^[A-z][A-z0-9]{1,31}$")

    def __init__(self, val):
        if not isinstance(val, basestring):
            raise ArgumentTypeError("val", type(val), "basestring")
        if not self.regex.match(val):
            raise ArgumentValueError(
                "val", val,
                "must match regexp: %s" % self.regex.pattern)
        super(SensorName, self).__init__(val)


class StreamName(unicode):
    '''
    Type holds stream name. Its purpose is similar to ``SensorConfig`` type.
    '''
    # R0904: Too many public methods.
    # pylint: disable=R0904

    regex = re.compile(r"^[A-z][A-z0-9]{1,15}$")

    def __init__(self, val):
        if not isinstance(val, basestring):
            raise ArgumentTypeError("val", type(val), "basestring")
        if not self.regex.match(val):
            raise ArgumentValueError(
                "val", val,
                "must match regexp: %s" % self.regex.pattern)
        super(StreamName, self).__init__(val)


class AgentRequest(list):
    '''
    This type is being used in agent <> collector communication. It holds list
     of ``AgentRequestChunk`` objects.
    '''
    pass


class AgentRequestChunk(object):
    '''
    Holds single information entry received from sensor:

        #. config_id
        #. stream_name
        #. timestamp
        #. data
    '''
    # R0904: Too few public methods.
    # pylint: disable=R0903

    def __init__(self, config_id, stream_name, timestamp, data):
        self.config_id = config_id
        self.stream_name = stream_name
        self.timestamp = timestamp
        self.data = data

    def __repr__(self):
        return "{}<{}>(config_id={}, stream_name={}, timestamp={}, data={})" \
               .format(self.__class__.__name__, type(self.data).__name__,
                       self.config_id, self.stream_name, self.timestamp,
                       self.data)


class CertificateState(Enum):
    '''
    Tells which certificates state(s) should be retrieved from the backend.
    '''
    # Too few public methods.
    # Class has no __init__ method.
    # pylint: disable=R0903,W0232

    signed = 'signed'
    unsigned = 'unsigned'
    revoked = 'revoked'
    rejected = 'rejected'


#: Global Type Registry object
PRIMITIVE_TYPE_REGISTRY = PrimitiveTypeRegistry()
PRIMITIVE_TYPE_REGISTRY.register_many((
    bool, float, str, datetime,
    ID, SensorName, LogDBConfigEntry, SensorConfig, StreamName,
    AgentRequest, AgentRequestChunk,
    CertificateState,
))
